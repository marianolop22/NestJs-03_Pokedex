name: Auto Update Changelog

on:
  push:
    branches: [ main, master ]

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.token }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Generate Enhanced Changelog
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          
          # Obtener URL del repositorio para los links
          REPO_URL=$(git config --get remote.origin.url)
          # Convertir SSH a HTTPS si es necesario
          if [[ $REPO_URL == git@github.com:* ]]; then
            REPO_URL="https://github.com/${REPO_URL#git@github.com:}"
            REPO_URL="${REPO_URL%.git}"
          elif [[ $REPO_URL == https://github.com/* ]]; then
            REPO_URL="${REPO_URL%.git}"
          fi
          
          # Verificar si ya existe una entrada para esta versión
          if [ -f CHANGELOG.md ] && grep -q "## \[v$CURRENT_VERSION\]" CHANGELOG.md; then
            echo "Versión $CURRENT_VERSION ya existe en changelog, saltando..."
            exit 0
          fi
          
          # Crear archivo temporal para la nueva entrada
          echo "## [v$CURRENT_VERSION] - $(date '+%Y-%m-%d')" > temp_changelog.md
          echo "" >> temp_changelog.md
          
          # Buscar el último commit que cambió package.json (versión anterior)
          LAST_VERSION_COMMIT=$(git log -n 2 --pretty=format:"%H" -- package.json | tail -n 1 2>/dev/null || echo "")
          
          if [ -n "$LAST_VERSION_COMMIT" ]; then
            # Commits desde el último cambio de versión (mensaje|hash)
            COMMITS=$(git log --oneline --pretty=format:"%s|%h" $LAST_VERSION_COMMIT..HEAD | grep -v "docs: auto-update CHANGELOG")
            
            if [ -n "$COMMITS" ]; then
              echo "### Cambios:" >> temp_changelog.md
              echo "$COMMITS" | while IFS='|' read -r commit hash; do
                # Crear link del commit
                COMMIT_LINK="[$hash]($REPO_URL/commit/$hash)"
                
                # Categorizar commits
                if echo "$commit" | grep -q "^feat"; then
                  echo "- ✨ $commit ($COMMIT_LINK)" >> temp_changelog.md
                elif echo "$commit" | grep -q "^fix"; then
                  echo "- 🐛 $commit ($COMMIT_LINK)" >> temp_changelog.md
                elif echo "$commit" | grep -q "^docs"; then
                  echo "- 📝 $commit ($COMMIT_LINK)" >> temp_changelog.md
                elif echo "$commit" | grep -q "^style"; then
                  echo "- 💄 $commit ($COMMIT_LINK)" >> temp_changelog.md
                elif echo "$commit" | grep -q "^refactor"; then
                  echo "- ♻️ $commit ($COMMIT_LINK)" >> temp_changelog.md
                elif echo "$commit" | grep -q "^test"; then
                  echo "- ✅ $commit ($COMMIT_LINK)" >> temp_changelog.md
                else
                  echo "- 🔧 $commit ($COMMIT_LINK)" >> temp_changelog.md
                fi
              done
            else
              echo "- Sin cambios desde la última versión" >> temp_changelog.md
            fi
          else
            echo "### Primera versión:" >> temp_changelog.md
            git log --oneline --pretty=format:"%s|%h" | head -10 | while IFS='|' read -r commit hash; do
              COMMIT_LINK="[$hash]($REPO_URL/commit/$hash)"
              echo "- 🔧 $commit ($COMMIT_LINK)" >> temp_changelog.md
            done
          fi
          
          echo "" >> temp_changelog.md
          echo "---" >> temp_changelog.md
          echo "" >> temp_changelog.md
          
          # Si existe CHANGELOG.md, preservar contenido anterior
          if [ -f CHANGELOG.md ]; then
            # Verificar si tiene header, si no, agregarlo
            if ! grep -q "# Changelog" CHANGELOG.md; then
              echo "# Changelog" > final_changelog.md
              echo "" >> final_changelog.md
              echo "Todas las versiones y cambios del proyecto." >> final_changelog.md
              echo "" >> final_changelog.md
              cat temp_changelog.md >> final_changelog.md
              cat CHANGELOG.md >> final_changelog.md
            else
              # Insertar nueva entrada después del header
              sed '/^# Changelog/,/^$/{ /^$/r temp_changelog.md
              }' CHANGELOG.md > final_changelog.md
            fi
          else
            # Crear nuevo archivo con header
            echo "# Changelog" > final_changelog.md
            echo "" >> final_changelog.md
            echo "Todas las versiones y cambios del proyecto." >> final_changelog.md
            echo "" >> final_changelog.md
            cat temp_changelog.md >> final_changelog.md
          fi
          
          # Reemplazar el archivo original
          mv final_changelog.md CHANGELOG.md
          rm -f temp_changelog.md
      
      - name: Check for changes
        id: verify-changed-files
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Commit and push changes
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git commit -m "docs: auto-update CHANGELOG.md v$(node -p 'require(\"./package.json\").version') [skip ci]"
          git push