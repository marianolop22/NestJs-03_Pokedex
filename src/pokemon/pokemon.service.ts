import { BadRequestException, Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import { Model, isValidObjectId } from 'mongoose';
import { Pokemon } from './entities/pokemon.entity';
import { InjectModel } from '@nestjs/mongoose';

import { CreatePokemonDto } from './dto/create-pokemon.dto';
import { UpdatePokemonDto } from './dto/update-pokemon.dto';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { AxiosAdapter } from 'src/common/adapters/axios.adapter';
import { PaginationDto } from 'src/common/dtos/pagination.dto';
import { ConfigService } from '@nestjs/config';


// Generated by https://quicktype.io
export interface PokeResponse {
  count:    number;
  next:     string;
  previous: null;
  results:  Result[];
}

export interface Result {
  name: string;
  url:  string;
}

@Injectable()
export class PokemonService {

  private defaultLimit: number;

  constructor(
    @InjectModel(Pokemon.name)
    private pokemonModel: Model<Pokemon>,
    private readonly httpService: HttpService,
    private readonly http: AxiosAdapter,
    private readonly configServive: ConfigService
  ) {
    this.defaultLimit = this.configServive.get<number>('defaultLimit');
  }

  async create(createPokemonDto: CreatePokemonDto) {
    try {
      const pokemon = await this.pokemonModel.create(createPokemonDto);
      return pokemon;
    } catch (error) {
      this.handleExceptions(error);
    }
  }

  findAll(paginationDto: PaginationDto) {
    return this.pokemonModel.find()
      .limit(paginationDto.limit ?? this.defaultLimit)
      .skip(paginationDto.offset ?? 0)
      .sort({
        no: 1
      });
  }

  async findOne(search: string) {

    let pokemon: Pokemon;

    if (!isNaN(+search)) {
      pokemon = await this.pokemonModel.findOne({ no: search });
    } else if (isValidObjectId(search)) {
      pokemon = await this.pokemonModel.findById(search);
    } else {
      pokemon = await this.pokemonModel.findOne({name: search.toLowerCase()});
    }

    if(!pokemon) {
      throw new NotFoundException('No existe el pokemon');
    }

    return pokemon;
  }

  async update(search: string, updatePokemonDto: UpdatePokemonDto) {
    const pokemon = await this.findOne(search);
    try {
      await pokemon.updateOne(updatePokemonDto);
      return {
        ...pokemon.toJSON(),
        ...updatePokemonDto
      };
    } catch (error) {
      this.handleExceptions(error);
    }
  }

  async remove(_id: string) {
    const {deletedCount} = await this.pokemonModel.deleteOne({_id});
    if(deletedCount === 0) {
      throw new BadRequestException('El id no existe');
    }
    return;
  }

  private handleExceptions( error: any) {
    if (error.code === 11000) {
      throw new BadRequestException('El pokemon ya existe');
    }
    throw new InternalServerErrorException('Cant create - check logs');
  }


  async seed() {
    await this.pokemonModel.deleteMany({});
    const { data } = await firstValueFrom (this.httpService.get<PokeResponse>('https://pokeapi.co/api/v2/pokemon?limit=650'));
    const pokemonToInsert: {no: number, name: string}[] = [];



    // data.results.forEach(async({name, url}) => {
    //   const segments = url.split('/');
    //   const no = +segments[ segments.length - 2];
    //   await this.create({ no , name});
    // })
    // return 'Listo';

    data.results.forEach(async({name, url}) => {
      const segments = url.split('/');
      const no = +segments[ segments.length - 2];
      pokemonToInsert.push({ no , name});
    });

    await this.pokemonModel.insertMany(pokemonToInsert);
    return 'Listo';
  }


}
